---
title: "R unit testing"
output:
   github_document:
      toc: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(cache = FALSE)
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(fig.path = "img/")
```

# Introduction

Notes from the [R Packages book](https://r-pkgs.org/testing-basics.html).

## Initial setup

To use testthat with your package, run:

    usethis::use_testthat(3)

This will:

1. Create a `tests/testthat` directory.
2. Add testthat to the `Suggests` field in the `DESCRIPTION` and specify
   testthat 3e in the `Config/testthat/edition` field. The updated
   `DESCRIPTION` fields might look like:

    Suggests: testthat (>= 3.0.0)
    Config/testthat/edition: 3

3. Create a file `tests/testthat.R` that runs all your tests when `R CMD check`
   runs. For a package named "pkg", the contents of this file will be something
   like:

    library(testthat)
    library(pkg)

    test_check("pkg")

Do not edit `tests/testthat.R` manually. It is run during `R CMD check` (and,
therefore, `devtools::check())`, but is not used in most other test-running
scenarios (such as `devtools::test()` or `devtools::test_active_file()`). If
you want to do something that affects all of your tests, there is almost always
a better way than modifying the boilerplate `tests/testthat.R` script.

This initial setup is usually something you do once per package.

## Creating a test

As you define functions in your packages in `R/`, you add the corresponding
tests to `.R` files in `tests/testthat`. It is strongly recommended that the
organisation of test files match the organisation of `R/` files.

For example if a `foofy()` function (and its friends and helpers) are defined
in `R/foofy.R`, their tests should reside in `tests/testthat/test-foofy.R`.

Even if you have different conventions for file organisation and naming, note
that testthat tests **must** reside in files inside `tests/testthat/` and these
file names **must** begin with `test`. The test file name is displayed in
testthat output, which provides helpful context.

usethis offers a helpful pair of functions for creating or toggling between files:

* `usethis::use_r()`
* `usethis::use_test()`

Either one can be called with a file (base) name in order to create a new file
and open it for editing.

Create and open `R/foofy.R`.

    use_r("foofy")

Create and open `tests/testthat/test-blarg.R`.

    use_test("blarg")

These two function has some convenience features that make them useful in many
common situations:

* When determining the target file, they can deal with the presence or absence
  of the `.R` extension and the `test-` prefix.
    * `use_r("foofy.R")` and `use_r("foofy")` are the same.
    * `use_test("test-blarg.R")`, `use_test("blarg.R")`, and
      `use_test("blarg")` are the same.
* If the target file already exists, it is open for editing. Otherwise the
  target is created and then opened for editing.

Furthermore, in RStudio, if `R/foofy.R` is the active file in the source pane,
calling `use_test()` with no arguments will create and/or open the companion
test file. This works the other way around too with `use_r()`.

When `use_test()` creates a new test file, it inserts an example test:

```
test_that("multiplication works", {
   expect_equal(2 * 2, 4)
})
```

* A test file holds one or more `test_that()` tests.
* Each test describes what it is testing such as whether multiplication works.
* Each test has one or more expectations, e.g. `expect_equal(2 * 2, 4)`.

## Running tests

Tests can be run at various scales depending on the development cycle. For
example when working on a specific function, testing will be performed at the
level of individual tests. As the code matures, testing will be performed on
entire test files and eventually the entire test suite.

## Session info

This document was generated by rendering `testing.Rmd` using `./rmd_to_md.sh`.

```{r time, echo=FALSE}
Sys.time()
```

Session info.

```{r session_info, echo=FALSE}
sessionInfo()
```
