---
title: "Learning R"
output:
   github_document:
      toc: true
---

```{r setup, include=FALSE}
library(tidyverse)
theme_set(theme_bw())
knitr::opts_chunk$set(cache = FALSE)
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(fig.path = "img/")
```

# Learning R

The three core features of R are object-orientation, vectorisation, and its functional programming style.

>"To understand computations in R, two slogans are helpful:
>
>* Everything that exists is an object.
>* Everything that happens is a function call."
>
> --John Chambers

Install packages if missing and load.

```{r load_package, message=FALSE, warning=FALSE}
.libPaths('/packages')
my_packages <- 'beepr'

for (my_package in my_packages){
   if(!require(my_package, character.only = TRUE)){
      install.packages(my_package, '/packages')
   }
  library(my_package, character.only = TRUE)
}
```

## Vectors

R is a vectorised language and what this means is that you can perform operations on vectors without having to iterate through each element. A vector is simply "a single entity consisting of a collection of things" but these items must all belong to the same class. If you try to create a vector with different classes, the vector will be coerced in the following order: `logical` < `integer` < `numeric` < `character`.

```{r vector_coercion}
my_char <- c(1, 3.14, TRUE, 'str')
class(my_char)

my_num <- c(1, 2, 3.14, 4)
class(my_num)
```

You can easily square each number in a vector by applying a exponential function.

```{r my_int_squared}
my_int <- 1:6
my_int^2
```

You can operate on a vector using another vector too. If the right vector isn't the same length as the left vector but is a multiple, R performs a procedure called "recycling" that will re-use the right vector on the next set of values.

```{r vec_recycling}
my_int + c(1, 2)
```

Named vectors can be used as simple lookup tables.

```{r lookup_table}
my_lookup <- c(
  "HKG" = "Hong Kong",
  "PNG" = "Papua New Guinea",
  "AUS" = "Australia",
  "JPN" = "Japan"
)

my_lookup["PNG"]
```

## Lists

Unlike vectors, lists can be used to store heterogeneous things.

```{r my_list}
my_list <- list(
  my_func = function(x){x^2},
  my_df = data.frame(a = 1:3),
  my_vec = 1:6
)

my_list$my_func(my_list$my_vec)
```

`lapply` can be used to apply a function to each item in a list and will return a list.

```{r lapply}
my_list <- list(
  a = 1:3,
  b = 4:10,
  c = 11:20
)

lapply(my_list, sum)
```

Another handy function is the `do.call` function, which constructs and executes a function call on a list. The example below is useful for converting a list into a matrix.

```{r do_call}
my_list <- list(
  a = 1:3,
  b = 4:6,
  c = 7:9
)

# returns a matrix
do.call(what = rbind, args = my_list)
```

There is also the [purrr::map](https://purrr.tidyverse.org/reference/map.html) function, that is [similar](https://jennybc.github.io/purrr-tutorial/ls01_map-name-position-shortcuts.html) to the apply functions in base R, but you explicitly specify the output type. The `map_lgl` function will return logicals, i.e. Booleans.

```{r map_lgl}
map_lgl(.x = 1:10, .f = function(x) x > 5)
```

## Objects

[Base types](https://adv-r.hadley.nz/base-types.html).

## General

Assign a data frame column `NULL` to delete it.

```{r exorcise}
my_df <- data.frame(
  a = 1:3,
  b = 4:6,
  c = c(6, 6, 6)
)

my_df$c <- NULL

my_df
```

Include an additional directory (`/packages`) to look for and install R packages.

```{r lib_paths}
.libPaths('/packages')
```

Use `identical` to check whether two objects are exactly equal. Most times it should suffice to just use `all.equal`.

```{r identical}
first <- 1:5
second <- c(1, 2, 3, 4, 5)

# this is false because first is a vector of integers
# and second is a vector of numerics
identical(first, second)

all.equal(first, second)
```

Set `scipen` (default is 0), which is a penalty to be applied when deciding to print numeric values in fixed or exponential notation, to determine when to print in exponential notation. (`.Options` contains all other options settings.)

```{r scipen}
options(scipen=0)
10e4
options(scipen=1)
10e4
```

Use `system.time()` to measure how long a block of codes takes to execute.

```{r system_time}
system.time(
  for (i in 1:100000000){}
)
```

The `with` function evaluates an expression with data.

```{r with_example}
my_df <- data.frame(
  a=1:10,
  b=11:20,
  c=21:30
)
wanted <- with(my_df, a > 5 & c > 27)
my_df[wanted, ]
```

The `which` function is a very useful for returning indicates that are `TRUE` and works with matrices.

```{r which}
my_mat <- matrix(1:9, nrow=3, byrow = TRUE)

# note that the results are ordered by col
which(my_mat > 5, arr.ind = TRUE)
```

The `match` function can be used with vectors to return the indexes of matching items and an `NA` is no match was found.

```{r match_xy}
x <- c('b', 'c', 'a', 'd')
y <- letters[1:3]

match(x, y)
```

You can use `match` to subset and order a data frame.

```{r match_subset}
my_df <- data.frame(
  a = 1:10,
  b = letters[1:10]
)

x <- c(2, 10, 5, 6)
x_match <- match(x, my_df$a)

my_df[x_match, ]
```

Use the `complete.cases` function to list observations that have no missing values, i.e. NA values.

```{r complete_cases}
my_df <- data.frame(
  a = 1:3,
  b = c(4, NA, 6),
  c = 7:9
)

complete.cases(my_df)
```

Use `commandArgs` to accept command line arguments without having to install an external package like `optparse`.

```{r command_args}
args <- commandArgs(TRUE)
```

## Useful plots

Visualise a table.

```{r mosaicplot}
mosaicplot(table(ChickWeight$Time, ChickWeight$Diet), main = "Timepoint versus diet")
```

## Useful tips

A lot of R books are free to read; check out the [bookdown](https://bookdown.org/) page to see some of the best R books.

R has four special values:

1. `NA` - used for representing missing data.
2. `NULL` - represents not having a value and unlike `NA`, it is its own object and cannot be used in a vector.
3. `Inf`/`-Inf` - used for representing numbers too big for R (see below).
4. `NaN` - used for storing results that are not a number.

Check the `.Machine` variable to find out the numerical characteristics of the machine R is running on, such as the largest double or integer and the machine's precision.

```{r machine}
noquote(unlist(format(.Machine)))
```

When asking for help online, it is useful to include a minimal example that includes some data specific to your question. To easily convert data into code, use the `dput()` function. The example below is just for illustrative purposes since the `women` dataset is included with R, so you would not need to generate code for it.

```{r dput}
dput(women)
```

Show all the functions of a package.

```{r stringr_functions}
ls("package:stringr")
```

Search is useful to list the search path, i.e. where R will look, for R objects such as functions.

```{r search_path}
search()
```

### Getting help

Get help on a class.

```{r numeric_class_help, eval=FALSE}
?"numeric-class"
```

Get information on a package.

```{r stringr_help, eval=FALSE}
library(help="stringr")
```

Finding out what methods are available for a class.

```{r lm_methods}
methods(class="lm")
```

Search the help pages.

```{r help_search, eval=FALSE}
help.search("cross tabulate")
```

Search for function containing keyword.

```{r apropos}
apropos("mutate")
```

## Hacks

There are probably better ways to do the following, which is why I have labelled them as hacks, so follow at your own peril.

### Library paths

Some R packages require libraries not included in the default library path. Use `Sys.setenv` to include additional library paths. First we'll get the default path.

```{r get_ld_library_path}
Sys.getenv("LD_LIBRARY_PATH")
```

Now we will add `/usr/include` to `LD_LIBRARY_PATH` and get the updated library path.

```{r set_ld_library_path}
new_path <- paste0(Sys.getenv("LD_LIBRARY_PATH"), ":", "/usr/include")
Sys.setenv("LD_LIBRARY_PATH" = new_path)
Sys.getenv("LD_LIBRARY_PATH")
```

### Variables and objects

Sometimes you want to create objects with values stored in variables. This can be achieved using `assign()`.

```{r assign}
my_varname <- 'one_to_ten'
my_values <- 1:10
assign(my_varname, my_values)

one_to_ten
```

Likewise, sometimes you want to store an object's name into a variable. This can be achieved using `substitute` (returns the parse tree for an unevaluated expression) and `deparse` (turns unevaluated expressions into character strings).

```{r obj_to_string}
obj_to_string <- function(x){
   deparse(substitute(x))
}

my_obj_name <- 1984
my_var <- obj_to_string(my_obj_name)

my_var
```

To evaluating a string, use `parse` (returns an unevaluated expression) with a `text` argument specifying the character vector and `eval` (evaluates an unevaluated expression).

```{r eval}
eval(parse(text = my_var))
```

## Session info

This README was generated by running `readme.Rmd` in RStudio Server.

```{r time, echo=FALSE}
Sys.time()
```

Session info.

```{r session_info, echo=FALSE}
sessionInfo()
```