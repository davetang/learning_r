---
title: "Object-Oriented Programming in R"
output:
   github_document:
      toc: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(cache = FALSE)
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(fig.path = "img/")

.libPaths('/packages')
my_packages <- c('sloop')

using<-function(...) {
   # https://stackoverflow.com/a/44660688
   libs<-unlist(list(...))
   req<-unlist(lapply(libs,require,character.only=TRUE))
   need<-libs[req==FALSE]
   if(length(need)>0){
      install.packages(need)
      lapply(need,require,character.only=TRUE)
   }
}

using(my_packages)
```

# Introduction

Notes from the [Advanced R](https://adv-r.hadley.nz/oo.html).

Everything that exists in R is an object but this does not mean that everything
is object-oriented. In R there are **base objects** and **OO objects** and we
can use `is.object()` or `sloop::otype()` to tell which is which.

```{r object_type}
is.object(1:10)
sloop::otype(1:10)

is.object(mtcars)
sloop::otype(mtcars)
```

Technically, the difference between base and OO objects is that OO objects have
a "class" attribute.

```{r attribute}
attr(1:10, "class")
attr(mtcars, "class")
```

The `class()` function is safe to apply to S3 and S4 objects but returns
misleading results when applied to base objects. It is safer to use
`sloop::s3_class()`, which returns the implicit class that the S3 and S4 systems
will use to pick methods.

```{r s3_class}
x <- matrix(1:4, nrow = 2)
class(x)
sloop::s3_class(x)
```

## Base types

While only OO objects have a class attribute, every object has a **base type**.

```{r typeof}
typeof(1:10)
typeof(mtcars)
```

Base types do not form an OOP system because functions that behave differently
for different base types are primarily written in C code that uses switch
statements. This means that only R-core can create new types, and creating a new
type is a lot of work because every switch statement needs to be modified to
handle a new case.

### Numeric type

R uses numeric to mean three slightly different things:

1. In some places numeric is used as an alias for the double type.
2. In the S3 and S4 systems, numeric is used as a shorthand for either integer
   or double type, and is used when picking methods:

```{r numeric_type}
sloop::s3_class(1)
sloop::s3_class(1L)
```

3. `is.numeric()` tests for objects that _behave_ like numbers. For example,
   factors have type "integer" but do not behave like numbers.

```{r factor_type}
typeof(factor("x"))
is.numeric(factor("x"))
```

## S3

An S3 object is a base type with at least a `class` attribute. As an example,
consider the factor. Its base type is the integer vector and it has a `class`
attribute of "factor" and a `levels` attribute that stores the possible levels.

```{r factor_example}
f <- factor(c("a", "b", "c"))

typeof(f)
attributes(f)
```

You can get the underlying base type by using `unclass()`, which strips the
class attribute, causing it to lose its special behaviour.

```{r unclass_a_factor}
unclass(f)
```

An S3 object behaves differently from its underlying base type whenever it is
passed to a **generic** (short for generic function). The easiest way to tell
if a function is a generic is to use `sloop::ftype()` and look for "generic" in
the output.

```{r ftype}
ftype(print)
ftype(str)
ftype(unclass)
```

A generic function defines an interface, which uses a different implementation
depending on the class of an argument (almost always the first argument).

```{r print_unclass}
print(f)

# stripping class reverts to integer behaviour
print(unclass(f))
```

The generic is a middleman: its job is to define the interface (i.e. the
arguments) then find the right implementation for the job. The implementation
for a specific class is called a **method**, and the generic finds that method
by performing **method dispatch**.

You can use `sloop::s3_dispatch()` to see the process of method dispatch.

```{r s3_dispath}
sloop::s3_dispatch(print(f))
```

Note that S3 methods are functions with a special naming scheme
`generic.class()`. For example, the `factor` method for the `print()` generic
is called `print.factor()`. **You should never call the method directly, but
instead rely on the generic to find it for you**.

Generally, you can identify a method by the presence of `.` in the function
name but use `sloop::ftype()` to confirm.

```{r ftype_check}
ftype(t.test)
ftype(t.data.frame)
```

**You can not see the source code for most S3 methods by typing their names
unlike most functions. That's because S3 methods are not usually exported: they
live only inside the package, and are not available from the global
environment**. Use `sloop::s3_get_method()` to get the method code.

```{r s3_get_method}
sloop::s3_get_method(weighted.mean.Date)
```

## Session info

This document was generated by rendering `oop.Rmd` using `rmd_to_md.sh`.

```{r time, echo=FALSE}
Sys.time()
```

Session info.

```{r session_info, echo=FALSE}
sessionInfo()
```
